#!/usr/bin/env ruby
require 'rubygems'
require 'roo_on_rails'
require 'thor'
require 'forwardable'
require 'singleton'
require 'active_support'
require 'hashie'
require 'platform-api'
require 'pry'

require 'roo_on_rails/checks'
require 'roo_on_rails/checks/helpers'

module RooOnRails
  module Checks
    class Base
      include Helpers

      # class_attribute :prerequisites
      # self.prerequisites = []


      def self.run(**options)
        new(**options).run
      end

      # def self.depends(req)
      #   prerequisites << req
      # end

      def initialize(fix: false, state: nil)
        @fix = fix
        @state = state
      end

      def run
        say _intro
        _call
      rescue Failure
        raise unless @fix
        say "\t· attempting to fix", %i[yellow]
        _fix
        say "\t· re-checking", %i[yellow]
        _call
      end

      protected

      def _intro
        self.class.name
      end

      def _call
        _fail "this check wasn't implemented"
      end

      def _fix
        _fail "can't fix this on my own"
      end

      def _state
        @state
      end

      def _run(cmd)
        result = Bundler.with_clean_env { %x{#{cmd}} }
        return [$?.success?, result]
      end

      def _run!(cmd)
        Bundler.with_clean_env { system(cmd) }
        raise CommandFailed.new(cmd) unless $?.success?
      end

      def _run?(cmd)
        Bundler.with_clean_env { system(cmd) }
        $?.success?
      end

      def _ok(msg)
        say "\t✔ #{msg}", :green
      end

      def _fail(msg)
        say "\t✘ #{msg}", :red
        raise Failure
      end
    end

    class Multi
      def initialize(variants:, of:)
        @_variants = variants
        @_of = of
      end

      def run(*args)
        @_variants.each do |v|
          @_of.new(v, *args).run
        end
      end
    end

    module Heroku
      class ToolbeltInstalled < Base
        def _intro
          "Checking if the Heroku Toolbelt is installed..."
        end

        def _call
          status, path = _run "which heroku"
          if status
            _ok "found #{bold path.strip} binary"
          else
            _fail "'heroku' binary missing"
          end
        end
      end

      class ToolbeltWorking < Base
        def _intro
          "Checking if the Heroku Toolbelt is working..."
        end

        def _call
          if _run? 'heroku status > /dev/null'
            _ok 'read heroku status'
          else
            _fail "could not run 'heroku status'"
          end
        end
      end

      class Login < Base
        def _intro
          "Checking if you're signed in to Heroku..."
        end

        def _call
          status, email = _run "heroku whoami"
          if status
            _ok "logged in as #{bold email.strip}"
          else
            _fail "not logged in"
          end
        end

        def _fix
          _run! "heroku login --sso"
        end
      end

      class Token < Base
        def _intro
          "Obtaining Heroku auth token..."
        end

        def _call
          status, token = _run "heroku auth:token"
          _fail "could not get a token" unless status

          _state.heroku!.api_client = PlatformAPI.connect_oauth(token.strip)
          _ok "connected to Heroku's API"
        end
      end

      class AppExists < Base
        def initialize(env, **options)
          super(options)
          @_env = env
        end
        
        def _intro
          "Checking if #{bold @_env} app exist..."
        end

        def _call
          all_apps = _client.app.list.map { |a| a['name'] }
          including_name = all_apps.select { |a| a.include?(_state.git_repo) }
          if including_name.empty?
            _fail "no apps with names including #{bold _state.git_repo} were detected"
          end

          correct_app = all_apps.select { |a| a =~ /^(roo-)?#{_state.git_repo}-#{@_env}$/ }

          unless correct_app.one?
            _hardfail "some apps with name #{bold _state.git_repo} exist, but I can't tell which one is for environment #{bold @_env}"
          end

          _state.heroku.app![@_env] = correct_app.first
          _ok "found app #{bold correct_app.first}"
        end

        private

        def _client
          _state.heroku.api_client
        end
      end

      AppsExist = Multi.new(variants: %w[staging production], of: AppExists)

      class PrebootEnabled < Base
        All = Multi.new(variants: %w[staging production], of: self)

        def initialize(env, **options)
          super(options)
          @_env = env
        end
        
        def _intro
          "Checking preboot status on #{bold _app}"
        end

        def _call
          status = _client.app_feature.info(_app, 'preboot')
          if status['enabled']
            _ok 'preboot enabled'
          else
            _fail 'preboot disabled'
          end
        end

        private

        def _fix
          _client.app_feature.update(_app, 'preboot', enabled: true)
        end

        def _app
          _state.heroku.app[@_env]
        end

        def _client
          _state.heroku.api_client
        end
      end
    end

    module Git
      class Origin < Base
        def _intro
          "Checking your Git origin remote..."
        end

        def _call
          status, url = _run "git config remote.origin.url"
          _fail "Origin does not seem to be configured." unless status
          
          org, repo = url.strip.gsub(%r{\.git$}, '').split(%r{[:/]}).last(2)
          _state.git_org  = org
          _state.git_repo = repo
          _ok "organisation #{bold org}, repository: #{bold repo}"
        end
      end
    end
  end

  class Harness
    include Thor::Shell

    def initialize(try_fix: false)
      @try_fix = try_fix
      @state = Hashie::Mash.new
    end

    def run
      # TODO: tsort dependencies between checks
      [
        Checks::Git::Origin,
        Checks::Heroku::ToolbeltInstalled,
        Checks::Heroku::ToolbeltWorking,
        Checks::Heroku::Login,
        Checks::Heroku::Token,
        Checks::Heroku::AppsExist,
        Checks::Heroku::PrebootEnabled::All,
      ].each do |c|
        c.run(fix: @try_fix, state: @state)
      end
      self
    rescue Checks::CommandFailed
      say 'A command failed to run, aborting', %i[bold red]
      exit 2
    rescue Checks::Failure
      say 'A check failed, exiting', %i[bold red]
      exit 1
    end
  end
end

RooOnRails::Harness.new(try_fix: true).run.tap { |h| binding.pry }

